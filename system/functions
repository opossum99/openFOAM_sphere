/*--------------------------------*- C++ -*----------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     | Website:  https://openfoam.org
    \\  /    A nd           | Version:  13
     \\/     M anipulation  |
\*---------------------------------------------------------------------------*/
FoamFile
{
    format      ascii;
    class       dictionary;
    location    "system";
    object      functions;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

//forces
//{
//    type            forceCoeffs;
//    libs            ("libforces.so");
//    writeControl    timeStep;
//    writeInterval   1;
//
//    //directForceDensity true;
//
//    patches
//    (
//        sphere
//    );
//
//    log         true;
//    rhoInf      1;
//    CofR        (0 0 0);
//    liftDir     (0 1 0);
//    dragDir     (1 0 0);
//    pitchAxis   (0 0 1);
//    magUInf     1;
//    lRef        1;
//    Aref        1;
//}

pressureForce
{
    type            coded;
    libs            ("libutilityFunctionObjects.so");
    name            pressureForce;

    // Dictionary entry for patch name
    patchName sphere;
    
    codeExecute
    #{
        const volScalarField& p = 
            mesh().lookupObject<volScalarField>("p");
        
        // Create patch set - can include multiple patches
	// Read patch name from dictionary
	// dictionary dict = {{"patchName", "sphere"}};
        // const word patchName(dict.lookup("patchName"));

        labelHashSet patchSet_;// = mesh().boundaryMesh().patchSet(this->dict());
        const label patchID = mesh().boundaryMesh().findIndex("sphere");
        
        if (patchID < 0)
        {
            FatalErrorInFunction
                << "Patch 'sphere' not found" << exit(FatalError);
        }
        
        patchSet_.insert(patchID);
        
        // Initialize global forces (for MPI reduction)
        scalar Fx_global = 0, Fy_global = 0, Fz_global = 0;
        
        // Iterate over patches in the set
        forAllConstIter(labelHashSet, patchSet_, iter)
        {
            const label patchi = iter.key();
            const fvPatch& patch = mesh().boundary()[patchi];
            
            // Get face area vectors
            const vectorField& Sf = patch.Sf();
            const scalarField sA(mag(Sf));
            
            // Pressure field
            const scalarField pf = p.boundaryField()[patchi];
            const vectorField fD(pf * Sf);
            
            // Normal (pressure) force only
            const vectorField fN(Sf/sA * (Sf & fD));
            
            // Integrate normal force (local processor)
            scalar Fx_local = 0, Fy_local = 0, Fz_local = 0;
            
            forAll(patch, faceI)
            {
                Fx_local += fN[faceI].x();
                Fy_local += fN[faceI].y();
                Fz_local += fN[faceI].z();
            }
            
            Fx_global += Fx_local;
            Fy_global += Fy_local;
            Fz_global += Fz_local;
        }
        
        // Reduce across all MPI processes
        reduce(Fx_global, sumOp<scalar>());
        reduce(Fy_global, sumOp<scalar>());
        reduce(Fz_global, sumOp<scalar>());
        
        // Write to file (only from master processor)
//        if (Pstream::master())
//        {
//            Ostream file("pressureForce.dat", true);
//            file << mesh().time().value() << " "
//                 << Fx_global << " " << Fy_global << " " << Fz_global << nl;
//        }
        
        // Print to console
        Info << "Time: " << mesh().time().value()
             << " Pressure Force: (" 
             << Fx_global << " " << Fy_global << " " << Fz_global << ")" << endl;
    #};
    
    executeControl  timeStep;
    executeInterval 1;
}


normalisedDensityGrad
{
    type coded;
    libs ("libutilityFunctionObjects.so");
    name normalisedDensityGrad;

    executeControl timeStep;
    executeInterval 100;

    codeInclude
    #{
        #include "volFields.H"
        #include "fvcGrad.H"
    #};

    codeOptions
    #{
        -I$(LIB_SRC)/finiteVolume/lnInclude \
        -I$(LIB_SRC)/OpenFOAM/lnInclude
    #};

    codeExecute
    #{
        const volScalarField& rho =
            mesh().lookupObject<volScalarField>("rho");

        // Compute gradient magnitude
        volScalarField G = mag(fvc::grad(rho));

        // volScalarField& refinementFieldNorm = mesh().lookupObject<volScalarField>("refinementFieldNorm");

        // Reference value
        scalar Gref = max(G).value() + SMALL;

        // Create and write normalised field (temporary, computed each step)
        static volScalarField refinementFieldNorm
        (
            IOobject
            (
                "refinementFieldNorm",
                mesh().time().name(),
                mesh(),
                IOobject::NO_READ,
                IOobject::AUTO_WRITE
            ),
            G / Gref
        );

        refinementFieldNorm = G;// / Gref;

        // Write to disk so dynamicRefineFvMesh can access it
        // refinementFieldNorm.write();

        Info << "Density gradient normalized - min: " << min(refinementFieldNorm).value()
             << " max: " << max(refinementFieldNorm).value() << endl;
    #};
}

// ************************************************************************* //
